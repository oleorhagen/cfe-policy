
body common control {
        bundlesequence => { "main" };
}

body file control
{
        inputs => {
                    "$(sys.libdir)/stdlib.cf",
                    "/home/olepor/misc/learn/cfe/mendersoftwaresync.cf", # git fetch, and config management
        };
}

# TODO -- How to get the private repositories
bundle agent main {

  vars:
      # TODO -- Use these variables for the getmenderrepos bundle function call?
      "users" slist =>
      {
        "mendersoftware",
        "oleorhagen"
      };
      "user_urls" slist =>
      {
        "https://api.github.com/orgs/mendersoftware/repos",
        "https://api.github.com/users/oleorhagen/repos"
      };

      "mendersoftware_section_template[mendersoftware][$(getmenderrepos.mendersoftware_mender_repos)]" string => "\
    $(const.t)url = git@github.com:mendersoftware/$(getmenderrepos.mendersoftware_mender_repos).git
    $(const.t)fetch = +refs/heads/*:refs/remotes/mendersoftware/*
    $(const.t)push=noPushUpstream";

      "mendersoftware_section_template[oleorhagen][$(getmenderrepos.oleorhagen_mender_repos)]" string => "\
    $(const.t)url = git@github.com:oleorhagen/$(getmenderrepos.oleorhagen_mender_repos).git
    $(const.t)fetch = +refs/heads/*:refs/remotes/oleorhagen/*";

      # Path to mendersoftware repository
      "location" string => "/home/olepor/mendersoftware/";

      "repos_intersection" slist => intersection( "getmenderrepos.mendersoftware_mender_repos", "getmenderrepos.oleorhagen_mender_repos" );

  methods:

      "menderrepos" usebundle => getmenderrepos("mendersoftware",
                                                "https://api.github.com/orgs/mendersoftware/repos");

      "oleorhagen_repos" usebundle => getmenderrepos("oleorhagen",
                                                     "https://api.github.com/users/oleorhagen/repos");

      "clone a repo locally, if it does not already exist"
        usebundle => git_clone( "$(location)", "$(repos_intersection)" );

      "fetch all remote updates"
        usebundle => git_fetch_all("$(location)$(repos_intersection)"),
        classes => if_notkept("$(repos)_failed"),
        action => if_elapsed("60");

  files:

      # add mendersoftware remote mendersoftware repos

      "$(location)$(getmenderrepos.mendersoftware_mender_repos)/.git/config"
        edit_line => git_config_section_replace("mendersoftware", "$(mendersoftware_section_template[mendersoftware][$(getmenderrepos.mendersoftware_mender_repos)])");


      # add oleorhagen remote to user repos

      "$(location)$(repos_intersection)/.git/config"
        edit_line => git_config_section_replace("oleorhagen", "$(mendersoftware_section_template[oleorhagen][$(repos_intersection)])");



  reports:
      "$(this.bundle): Ran main...";
      "$(this.bundle): menderepos: $(getmenderrepos.mendersoftware_json_response[$(getmenderrepos.jri)][name])";

      "$(this.bundle): menderrepos_list: $(getmenderrepos.mendersoftware_mender_repos)";

      "$(this.bundle): intersection: $(repos_intersection)";

}

bundle agent getmenderrepos(name, url) {

  vars:

      "github_outh_access_token" string => readfile("/home/olepor/.secrets/github_access_token", 50);

      "options_str" string => '
{
  "url.max_content": 1832960,
  "url.verbose": 0,
  "url.user-agent": "cf-agent",
  "url.headers": [ "Authorization: token $(github_outh_access_token)" ]
}';
      "options" data => parsejson( $(options_str) );
      # "url" string => "https://api.github.com/orgs/mendersoftware/repos";
      "response" data => url_get( $(url), options );
      "out" string => format("%S", response);

      "$(name)_json_response" data => parsejson( "$(response[content])" );

      # Get the indices for the returned object list
      "jri" slist => getindices( "$(name)_json_response" );

      "repo_name" string => "$($(name)_json_response[$(jri)][name])";

      "mender_array[$($(name)_json_response[$(jri)][name])]" string => "$($(name)_json_response[$(jri)][name])";

      "$(name)_mender_repos" slist => getvalues( mender_array );

  reports:
      # "$(this.bundle): from $(url) with options $(options_str) we got $(out)";
      # "$(this.bundle): response ($(response)) body we got $(response[content])";
      # "$(this.bundle): json-parsed: $(json_response)";
      # "$(this.bundle): JSON-object: $(json_object)";
      # "$(this.bundle): jri: $(jri)";
      "$(this.bundle): github_access_token: $(github_oath_access_token)";
      "$(this.bundle): repo_name: $(repo_name)";
      "$(this.bundle): repository names for $(name): $($(name)_json_response[$(jri)][name])";
      "$(this.bundle): mender_list: $(mender_repos)";

      # "$(this.bundle): repos: $(menderrepos_names)";
}

bundle agent foo
{
  vars:
      "foo" string => "bar";
}

# bundle agent main
# {
#   vars:
#     # The response from github api is /HUGE/. Probably you will need to increase
#     # the max_content size allowed for the response (it's 4k by default). I got
#     # an error from the github api unless I set a user agent.

#       "options" data => '{ "url.max_content": 10240000, "url.headers": [ "User-Agent: cf-agent" ]  }';
#       "url" string => "https://api.github.com/orgs/mendersoftware/repos";
#       "r" data => url_get( $(url), options);

#       # Strangely I can not seem to pull the index from the response content. I
#       # expect to get integers of their positions (0, 1, 2 ...)
#       # TODO File CFE BUG, apparently not possible to pull index from the content key in url_get() response 
#       "rci" slist => getindices( "r[content]" );
#       # Seems like it should be possible based on this mock data
#       "mock" data => '{ "content": [ { "name": "foo" }, { "name": "bar" } ] }';
#       "mci" slist => getindices( "mock[content]" );

#       # So, I will take the response, and render the content to a file and read that back in
#        "d" data => readjson( "/tmp/response.content", inf );
#        "di" slist => getindices( "d" );
#   files:
#    # CFE-?
#    # Work around strange issue where unable to get index from the content key of a url_get response
#    "/tmp/response.content" create => "true", template_method => "inline_mustache", template_data => @(r), edit_template_string => "{{%content}}";

#   reports:
#      "Response Content Index: $(rci)";
#      "Mock Content Index: $(mci)";
#      "File Content Index: $(di)";
#      "Repo Names";
#      "$(d[$(di)][name])";
# }
